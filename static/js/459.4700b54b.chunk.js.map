{"version":3,"file":"static/js/459.4700b54b.chunk.js","mappings":"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","sources":["webpack://samurai-way/./src/components/Users/Users.module.css?b9d0","webpack://samurai-way/./src/components/common/Paginator/Paginator.module.css?6caa","components/common/Paginator/Paginator.tsx","components/Users/User.tsx","components/Users/Users.tsx","../node_modules/reselect/dist/reselect.mjs","redux/users-selectors.ts","components/Users/Users.Container.tsx","hok/withAuthRedirect.tsx","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"Users_wrapper__t1L9U\",\"imageButton\":\"Users_imageButton__wpaPD\",\"foto\":\"Users_foto__+WliW\",\"description\":\"Users_description__zpKOk\",\"wrapper_name_status\":\"Users_wrapper_name_status__UJ90r\",\"location\":\"Users_location__l8GiJ\",\"listPages\":\"Users_listPages__K2Igx\"};","// extracted by mini-css-extract-plugin\nexport default {\"pages\":\"Paginator_pages__2M1rO\",\"selected\":\"Paginator_selected__xpXVG\",\"paginator\":\"Paginator_paginator__G9IiM\",\"pgn\":\"Paginator_pgn__XYwss\",\"numbers\":\"Paginator_numbers__0pMLq\"};","import s from \"./Paginator.module.css\";\r\nimport React, {useEffect, useState} from \"react\";\r\n\r\n\r\ntype PaginatorPropsType = {\r\n    totalUsersCount: number\r\n    pageSize: number\r\n    currentPage: number\r\n    changeCurrentPage: (p: number) => void\r\n}\r\n\r\n\r\nexport const Paginator = (props: PaginatorPropsType) => {\r\n\r\n    const [rightBorder, setRightBorder] = useState(10)\r\n    const [leftBorder, setLeftBorder] = useState(1)\r\n\r\n    let pagesCount: number[] = []\r\n\r\n    let count = Math.ceil(props.totalUsersCount / props.pageSize)\r\n\r\n\r\n    for (let i = leftBorder; i <= rightBorder; i++) {\r\n        pagesCount.push(i)\r\n    }\r\n\r\n    const setPaginatorBorder = (p: number) => {\r\n        if (p > 4 && p <= count - 5) {\r\n            setLeftBorder(p-4)\r\n            setRightBorder(p+5)\r\n        } else if (p < 4) {\r\n            setLeftBorder(1)\r\n            setRightBorder(10)\r\n        } else if (p > count - 5) {\r\n            setLeftBorder(count-10)\r\n            setRightBorder(count)\r\n        }\r\n\r\n    }\r\n\r\n    useEffect(() => {\r\n        setPaginatorBorder(props.currentPage)\r\n    })\r\n\r\n    const paginator = pagesCount.map(p => {\r\n        const finalSpanClass = s.pages + ' ' + (props.currentPage === p ? s.selected : '')\r\n        return <span\r\n            key={p}\r\n            className={finalSpanClass}\r\n            onClick={() => {\r\n                props.changeCurrentPage(p)\r\n                setPaginatorBorder(p)\r\n            }}\r\n        >\r\n        {p}\r\n            </span>\r\n    })\r\n\r\n    const buttonOnClick: React.MouseEventHandler<HTMLButtonElement> = (e) => {\r\n\r\n        if (e.currentTarget.name === 'start') {\r\n            setLeftBorder(1)\r\n            setRightBorder(10)\r\n            props.changeCurrentPage(1)\r\n        } else {\r\n            setLeftBorder(count-10)\r\n            setRightBorder(count)\r\n            props.changeCurrentPage(count)\r\n        }\r\n    }\r\n\r\n\r\n    return <div className={s.pgn}>\r\n        <button name={'start'} onClick={buttonOnClick}>в начало списка</button>\r\n        <div className={s.numbers}>\r\n            <div className={s.paginator}>\r\n                {leftBorder > 1 ? '...': ''}\r\n                {paginator}\r\n                {rightBorder < count ? '...': ''}\r\n            </div>\r\n        </div>\r\n        <button name={'finish'} onClick={buttonOnClick}>в конец списка</button>\r\n    </div>\r\n}","import s from \"./Users.module.css\";\r\nimport userPhoto from \"../../assets/images/User.png\";\r\nimport React from \"react\";\r\nimport {UserType} from \"../../redux/users-reducer\";\r\nimport {NavLink} from \"react-router-dom\";\r\n\r\n\r\ntype UserPropsType = {\r\n    user: UserType\r\n    followingInProgress: Array<number>\r\n    follow: (userId: number) => void\r\n    unfollow: (userId: number) => void\r\n}\r\n\r\n\r\nexport const User = (props: UserPropsType) => {\r\n    const {user} = props\r\n    return <>\r\n        <div key={user.id} className={s.wrapper}>\r\n            <div className={s.imageButton}>\r\n                <div className={s.foto}>\r\n                    <NavLink to={'/profile/' + user.id}>\r\n                        <img src={user.photos.small !== null ? user.photos.small : userPhoto} alt=\"\"/>\r\n                    </NavLink>\r\n                </div>\r\n\r\n                {user.followed\r\n                    ? <button\r\n                        disabled={props.followingInProgress.some(id => id === user.id)}\r\n                        onClick={() => {\r\n                            props.unfollow(user.id)\r\n                        }}\r\n                    >\r\n                        UNFOLLOW\r\n                    </button>\r\n                    : <button\r\n                        disabled={props.followingInProgress.some(id => id === user.id)}\r\n                        onClick={() => {\r\n                            props.follow(user.id)\r\n                        }}\r\n                    >\r\n                        FOLLOW\r\n                    </button>\r\n                }\r\n            </div>\r\n            <div className={s.description}>\r\n                <div className={s.wrapper_name_status}>\r\n                    <div className={s.name}>{user.name}</div>\r\n                    <div className={s.status}>{user.status}</div>\r\n                </div>\r\n                <div className={s.location}>\r\n                    <div>{'user.location.country'}</div>\r\n                    <div>{'user.location.city'}</div>\r\n                </div>\r\n                <div></div>\r\n            </div>\r\n        </div>\r\n    </>\r\n\r\n}","import s from \"./Users.module.css\";\r\nimport React from \"react\";\r\nimport {UserType} from \"../../redux/users-reducer\";\r\nimport {Preloader} from \"../common/Preloader/Preloader\";\r\nimport {Paginator} from \"../../components/common/Paginator/Paginator\";\r\nimport {User} from \"./User\";\r\n\r\n\r\ntype UsersNewPropsType = {\r\n    totalUsersCount: number\r\n    pageSize: number\r\n    currentPage: number\r\n    changeCurrentPage: (p: number) => void\r\n    users: Array<UserType>\r\n    isFetching: boolean\r\n    toggleFollowingProgress: (isFetching: boolean, userId: number) => void\r\n    followingInProgress: Array<number>\r\n    follow: (userId: number) => void\r\n    unfollow: (userId: number) => void\r\n}\r\n\r\n\r\nexport const Users = (props: UsersNewPropsType) => {\r\n\r\n    return (\r\n        <div>\r\n            {props.isFetching ? <Preloader/> : null}\r\n\r\n            <div className={s.listPages}>\r\n                <Paginator\r\n                    totalUsersCount={props.totalUsersCount}\r\n                    pageSize={props.pageSize}\r\n                    currentPage={props.currentPage}\r\n                    changeCurrentPage={props.changeCurrentPage}\r\n                />\r\n            </div>\r\n\r\n            {props.users.map((u) => {\r\n                return (\r\n                    <User\r\n                        key={u.id}\r\n                        user={u}\r\n                        followingInProgress={props.followingInProgress}\r\n                        follow={props.follow}\r\n                        unfollow={props.unfollow}\r\n                    />\r\n                )\r\n            })}\r\n        </div>\r\n    )\r\n}","// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n    let isInputSameAsOutput = false;\n    try {\n      const emptyObject = {};\n      if (resultFunc(emptyObject) === emptyObject)\n        isInputSameAsOutput = true;\n    } catch {\n    }\n    if (isInputSameAsOutput) {\n      let stack = void 0;\n      try {\n        throw new Error();\n      } catch (e) {\n        ;\n        ({ stack } = e);\n      }\n      console.warn(\n        \"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\",\n        { stack }\n      );\n    }\n  }\n};\n\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {\n  const { memoize, memoizeOptions } = options;\n  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);\n  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n  if (!areInputSelectorResultsEqual) {\n    let stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      ({ stack } = e);\n    }\n    console.warn(\n      \"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\",\n      {\n        arguments: inputSelectorArgs,\n        firstInputs: inputSelectorResults,\n        secondInputs: inputSelectorResultsCopy,\n        stack\n      }\n    );\n  }\n};\n\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = (devModeChecks) => {\n  Object.assign(globalDevModeChecks, devModeChecks);\n};\n\n// src/utils.ts\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {\n  if (typeof object !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {\n  if (!array.every((item) => typeof item === \"function\")) {\n    const itemTypes = array.map(\n      (item) => typeof item === \"function\" ? `function ${item.name || \"unnamed\"}()` : typeof item\n    ).join(\", \");\n    throw new TypeError(`${errorMessage}[${itemTypes}]`);\n  }\n}\nvar ensureIsArray = (item) => {\n  return Array.isArray(item) ? item : [item];\n};\nfunction getDependencies(createSelectorArgs) {\n  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(\n    dependencies,\n    `createSelector expects all input-selectors to be functions, but received the following types: `\n  );\n  return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  const inputSelectorResults = [];\n  const { length } = dependencies;\n  for (let i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n  return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {\n  const { identityFunctionCheck, inputStabilityCheck } = {\n    ...globalDevModeChecks,\n    ...devModeChecks\n  };\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n};\n\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = class {\n  revision = $REVISION;\n  _value;\n  _lastValue;\n  _isEqual = tripleEq;\n  constructor(initialValue, isEqual = tripleEq) {\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  }\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  get value() {\n    CURRENT_TRACKER?.add(this);\n    return this._value;\n  }\n  // Whenever a storage value is updated, we bump the global revision clock,\n  // assign the revision for this storage to the new value, _and_ we schedule a\n  // rerender. This is important, and it's what makes autotracking  _pull_\n  // based. We don't actively tell the caches which depend on the storage that\n  // anything has happened. Instead, we recompute the caches when needed.\n  set value(newValue) {\n    if (this.value === newValue)\n      return;\n    this._value = newValue;\n    this.revision = ++$REVISION;\n  }\n};\nfunction tripleEq(a, b) {\n  return a === b;\n}\nvar TrackingCache = class {\n  _cachedValue;\n  _cachedRevision = -1;\n  _deps = [];\n  hits = 0;\n  fn;\n  constructor(fn) {\n    this.fn = fn;\n  }\n  clear() {\n    this._cachedValue = void 0;\n    this._cachedRevision = -1;\n    this._deps = [];\n    this.hits = 0;\n  }\n  get value() {\n    if (this.revision > this._cachedRevision) {\n      const { fn } = this;\n      const currentTracker = /* @__PURE__ */ new Set();\n      const prevTracker = CURRENT_TRACKER;\n      CURRENT_TRACKER = currentTracker;\n      this._cachedValue = fn();\n      CURRENT_TRACKER = prevTracker;\n      this.hits++;\n      this._deps = Array.from(currentTracker);\n      this._cachedRevision = this.revision;\n    }\n    CURRENT_TRACKER?.add(this);\n    return this._cachedValue;\n  }\n  get revision() {\n    return Math.max(...this._deps.map((d) => d.revision), 0);\n  }\n};\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n  return cell.value;\n}\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\n      \"setValue must be passed a tracked store created with `createStorage`.\"\n    );\n  }\n  storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue, isEqual = tripleEq) {\n  return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n  assertIsFunction(\n    fn,\n    \"the first parameter to `createCache` must be a function\"\n  );\n  return new TrackingCache(fn);\n}\n\n// src/autotrackMemoize/tracking.ts\nvar neverEq = (a, b) => false;\nfunction createTag() {\n  return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\nvar consumeCollection = (node) => {\n  let tag = node.collectionTag;\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n  getValue(tag);\n};\nvar dirtyCollection = (node) => {\n  const tag = node.collectionTag;\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n};\n\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = class {\n  constructor(value) {\n    this.value = value;\n    this.value = value;\n    this.tag.value = value;\n  }\n  proxy = new Proxy(this, objectProxyHandler);\n  tag = createTag();\n  tags = {};\n  children = {};\n  collectionTag = null;\n  id = nextId++;\n};\nvar objectProxyHandler = {\n  get(node, key) {\n    function calculateResult() {\n      const { value } = node;\n      const childValue = Reflect.get(value, key);\n      if (typeof key === \"symbol\") {\n        return childValue;\n      }\n      if (key in proto) {\n        return childValue;\n      }\n      if (typeof childValue === \"object\" && childValue !== null) {\n        let childNode = node.children[key];\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n        return childNode.proxy;\n      } else {\n        let tag = node.tags[key];\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n        getValue(tag);\n        return childValue;\n      }\n    }\n    const res = calculateResult();\n    return res;\n  },\n  ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\nvar ArrayTreeNode = class {\n  constructor(value) {\n    this.value = value;\n    this.value = value;\n    this.tag.value = value;\n  }\n  proxy = new Proxy([this], arrayProxyHandler);\n  tag = createTag();\n  tags = {};\n  children = {};\n  collectionTag = null;\n  id = nextId++;\n};\nvar arrayProxyHandler = {\n  get([node], key) {\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys([node]) {\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor([node], prop) {\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has([node], prop) {\n    return objectProxyHandler.has(node, prop);\n  }\n};\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n  return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n  const { value, tags, children } = node;\n  node.value = newValue;\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      let oldKeysSize = 0;\n      let newKeysSize = 0;\n      let anyKeysAdded = false;\n      for (const _key in value) {\n        oldKeysSize++;\n      }\n      for (const key in newValue) {\n        newKeysSize++;\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n  for (const key in tags) {\n    const childValue = value[key];\n    const newChildValue = newValue[key];\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[key], newChildValue);\n    }\n    if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      delete tags[key];\n    }\n  }\n  for (const key in children) {\n    const childNode = children[key];\n    const newChildValue = newValue[key];\n    const childValue = childNode.value;\n    if (childValue === newChildValue) {\n      continue;\n    } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      updateNode(childNode, newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[key];\n    }\n  }\n}\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n  dirtyCollection(node);\n  for (const key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n  for (const key in node.children) {\n    deleteNode(node.children[key]);\n  }\n}\n\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n  let entry;\n  return {\n    get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put(key, value) {\n      entry = { key, value };\n    },\n    getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear() {\n      entry = void 0;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  let entries = [];\n  function get(key) {\n    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));\n    if (cacheIndex > -1) {\n      const entry = entries[cacheIndex];\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    }\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({ key, value });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return { get, put, getEntries, clear };\n}\nvar referenceEqualityCheck = (a, b) => a === b;\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n    const { length } = prev;\n    for (let i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };\n  const {\n    equalityCheck = referenceEqualityCheck,\n    maxSize = 1,\n    resultEqualityCheck\n  } = providedOptions;\n  const comparator = createCacheKeyComparator(equalityCheck);\n  let resultsCount = 0;\n  const cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n  function memoized() {\n    let value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        const entries = cache.getEntries();\n        const matchingEntry = entries.find(\n          (entry) => resultEqualityCheck(entry.value, value)\n        );\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = () => {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = () => resultsCount;\n  memoized.resetResultsCount = () => {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n  const node = createNode(\n    []\n  );\n  let lastArgs = null;\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  const cache = createCache(() => {\n    const res = func.apply(null, node.proxy);\n    return res;\n  });\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n    return cache.value;\n  }\n  memoized.clearCache = () => {\n    return cache.clear();\n  };\n  return memoized;\n}\n\n// src/weakMapMemoize.ts\nvar StrongRef = class {\n  constructor(value) {\n    this.value = value;\n  }\n  deref() {\n    return this.value;\n  }\n};\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\nfunction weakMapMemoize(func, options = {}) {\n  let fnNode = createCacheNode();\n  const { resultEqualityCheck } = options;\n  let lastResult;\n  let resultsCount = 0;\n  function memoized() {\n    let cacheNode = fnNode;\n    const { length } = arguments;\n    for (let i = 0, l = length; i < l; i++) {\n      const arg = arguments[i];\n      if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n        let objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        let primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    const terminatedNode = cacheNode;\n    let result;\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n    }\n    terminatedNode.s = TERMINATED;\n    if (resultEqualityCheck) {\n      const lastResultValue = lastResult?.deref?.() ?? lastResult;\n      if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n        result = lastResultValue;\n        resultsCount !== 0 && resultsCount--;\n      }\n      const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n      lastResult = needsWeakRef ? new Ref(result) : result;\n    }\n    terminatedNode.v = result;\n    return result;\n  }\n  memoized.clearCache = () => {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = () => resultsCount;\n  memoized.resetResultsCount = () => {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {\n  const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n  const createSelector2 = (...createSelectorArgs) => {\n    let recomputations = 0;\n    let dependencyRecomputations = 0;\n    let lastResult;\n    let directlyPassedOptions = {};\n    let resultFunc = createSelectorArgs.pop();\n    if (typeof resultFunc === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n    assertIsFunction(\n      resultFunc,\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n    );\n    const combinedOptions = {\n      ...createSelectorCreatorOptions,\n      ...directlyPassedOptions\n    };\n    const {\n      memoize,\n      memoizeOptions = [],\n      argsMemoize = weakMapMemoize,\n      argsMemoizeOptions = [],\n      devModeChecks = {}\n    } = combinedOptions;\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    const dependencies = getDependencies(createSelectorArgs);\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\n      recomputations++;\n      return resultFunc.apply(\n        null,\n        arguments\n      );\n    }, ...finalMemoizeOptions);\n    let firstRun = true;\n    const selector = argsMemoize(function dependenciesChecker() {\n      dependencyRecomputations++;\n      const inputSelectorResults = collectInputSelectorResults(\n        dependencies,\n        arguments\n      );\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\n      if (process.env.NODE_ENV !== \"production\") {\n        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(\n            resultFunc,\n            inputSelectorResults,\n            lastResult\n          );\n        }\n        if (inputStabilityCheck.shouldRun) {\n          const inputSelectorResultsCopy = collectInputSelectorResults(\n            dependencies,\n            arguments\n          );\n          inputStabilityCheck.run(\n            { inputSelectorResults, inputSelectorResultsCopy },\n            { memoize, memoizeOptions: finalMemoizeOptions },\n            arguments\n          );\n        }\n        if (firstRun)\n          firstRun = false;\n      }\n      return lastResult;\n    }, ...finalArgsMemoizeOptions);\n    return Object.assign(selector, {\n      resultFunc,\n      memoizedResultFunc,\n      dependencies,\n      dependencyRecomputations: () => dependencyRecomputations,\n      resetDependencyRecomputations: () => {\n        dependencyRecomputations = 0;\n      },\n      lastResult: () => lastResult,\n      recomputations: () => recomputations,\n      resetRecomputations: () => {\n        recomputations = 0;\n      },\n      memoize,\n      argsMemoize\n    });\n  };\n  Object.assign(createSelector2, {\n    withTypes: () => createSelector2\n  });\n  return createSelector2;\n}\nvar createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\n\n// src/createStructuredSelector.ts\nvar createStructuredSelector = Object.assign(\n  (inputSelectorsObject, selectorCreator = createSelector) => {\n    assertIsObject(\n      inputSelectorsObject,\n      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n    );\n    const inputSelectorKeys = Object.keys(inputSelectorsObject);\n    const dependencies = inputSelectorKeys.map(\n      (key) => inputSelectorsObject[key]\n    );\n    const structuredSelector = selectorCreator(\n      dependencies,\n      (...inputSelectorResults) => {\n        return inputSelectorResults.reduce((composition, value, index) => {\n          composition[inputSelectorKeys[index]] = value;\n          return composition;\n        }, {});\n      }\n    );\n    return structuredSelector;\n  },\n  { withTypes: () => createStructuredSelector }\n);\nexport {\n  createSelector,\n  createSelectorCreator,\n  createStructuredSelector,\n  lruMemoize,\n  referenceEqualityCheck,\n  setGlobalDevModeChecks,\n  autotrackMemoize as unstable_autotrackMemoize,\n  weakMapMemoize\n};\n","import {AppStateType} from \"./redux-store\";\r\nimport {UserType} from \"./users-reducer\";\r\nimport {createSelector} from \"reselect\";\r\n\r\nexport const getUsers = (state:AppStateType): Array<UserType> => {\r\n    return state.usersState.users\r\n}\r\n\r\nexport const getUsersNoReselect = (state:AppStateType): Array<UserType> => {\r\n    return getUsers(state).filter(u => true)\r\n}\r\n\r\nexport const getUsersWithReselect = createSelector(getUsers, (users) => {\r\n    return users.filter(u => true)\r\n})\r\n\r\n\r\nexport const getCurrentPage = (state:AppStateType): number => {\r\n    return state.usersState.currentPage\r\n}\r\n\r\nexport const getPageSize = (state:AppStateType): number => {\r\n    return state.usersState.pageSize\r\n}\r\n\r\nexport const getTotalUserCount = (state:AppStateType): number => {\r\n    return state.usersState.totalUsersCount\r\n}\r\n\r\nexport const getIsFetching = (state:AppStateType): boolean => {\r\n    return state.usersState.isFetching\r\n}\r\n\r\nexport const getFollowingInProgress = (state:AppStateType): number[] => {\r\n    return state.usersState.followingInProgress\r\n}\r\n","import {connect} from \"react-redux\";\r\nimport {AppStateType} from \"../../redux/redux-store\";\r\nimport {\r\n    follow, requestUsers,\r\n    setCurrentPage, toggleFollowingProgress,\r\n    unFollow, UserType\r\n} from \"../../redux/users-reducer\";\r\nimport {initialStateType} from \"../../redux/users-reducer\";\r\nimport React from \"react\";\r\nimport {Users} from \"./Users\";\r\nimport {withAuthRedirect} from \"../../hok/withAuthRedirect\";\r\nimport {compose} from \"redux\";\r\nimport {\r\n    getCurrentPage,\r\n    getFollowingInProgress,\r\n    getIsFetching,\r\n    getPageSize,\r\n    getTotalUserCount,\r\n    getUsersWithReselect\r\n} from \"../../redux/users-selectors\";\r\n\r\nclass UsersCompContainer extends React.Component<initialStateType & mapDispatchToPropsType> {\r\n\r\n    componentDidMount() {\r\n        let {currentPage, pageSize} = this.props\r\n        this.props.getUsers(currentPage, pageSize)\r\n    }\r\n    changeCurrentPage = (numberPage: number) => {\r\n        const {pageSize} = this.props\r\n        this.props.setCurrentPage(numberPage)\r\n        this.props.getUsers(numberPage, pageSize)\r\n    }\r\n\r\n\r\n    render() {\r\n            return (\r\n                <>\r\n                    <Users\r\n                        totalUsersCount = {this.props.totalUsersCount}\r\n                        pageSize = {this.props.pageSize}\r\n                        currentPage = {this.props.currentPage}\r\n                        changeCurrentPage = {this.changeCurrentPage}\r\n                        users = {this.props.users}\r\n                        isFetching={this.props.isFetching}\r\n                        followingInProgress={this.props.followingInProgress}\r\n                        toggleFollowingProgress={this.props.toggleFollowingProgress}\r\n                        follow={this.props.follow}\r\n                        unfollow={this.props.unFollow}\r\n                    />\r\n                </>\r\n                )\r\n    }\r\n}\r\n\r\nexport type mapDispatchToPropsType = {\r\n    follow: (id: number) => void\r\n    unFollow: (id: number) => void\r\n    setCurrentPage: (numberPage: number) => void\r\n    toggleFollowingProgress: (isFetching: boolean, userId: number) => void\r\n    getUsers: (currentPage: number, pageSize: number) => void\r\n}\r\n\r\ntype mapStateToPropsType = {\r\n    users: Array<UserType>\r\n    currentPage: number\r\n    pageSize: number\r\n    totalUsersCount: number\r\n    isFetching: boolean\r\n    followingInProgress: Array<number>\r\n}\r\n\r\n// const mapStateToProps = (state: AppStateType): initialStateType => {\r\n//     return {\r\n//         users: state.usersState.users,\r\n//         currentPage: state.usersState.currentPage,\r\n//         pageSize: state.usersState.pageSize,\r\n//         totalUsersCount: state.usersState.totalUsersCount,\r\n//         isFetching: state.usersState.isFetching,\r\n//         followingInProgress: state.usersState.followingInProgress\r\n//     }\r\n// }\r\n\r\nconst mapStateToProps = (state: AppStateType): mapStateToPropsType => {\r\n    return {\r\n        users: getUsersWithReselect(state),\r\n        currentPage: getCurrentPage(state),\r\n        pageSize: getPageSize(state),\r\n        totalUsersCount: getTotalUserCount(state),\r\n        isFetching: getIsFetching(state),\r\n        followingInProgress: getFollowingInProgress(state)\r\n    }\r\n}\r\n\r\nexport default compose<React.ComponentType>(\r\n    withAuthRedirect,\r\n    connect(mapStateToProps, {\r\n        follow,\r\n        unFollow,\r\n        setCurrentPage,\r\n        toggleFollowingProgress,\r\n        getUsers: requestUsers\r\n    })\r\n)(UsersCompContainer)\r\n\r\n","import React, {Component, ComponentType} from \"react\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport {connect} from \"react-redux\";\r\nimport {AppStateType} from \"../redux/redux-store\";\r\n\r\ntype mapStateToPropsType = {\r\n    isAuth: boolean\r\n}\r\n\r\nlet mapStateToProps = (state: AppStateType): mapStateToPropsType => {\r\n    return {\r\n        isAuth: state.auth.isAuth\r\n    }\r\n}\r\n\r\nexport function withAuthRedirect<T>(Component: ComponentType<T>) {  // <T> - тип принимаемого компонента\r\n\r\n    const RedirectComponent = (props: mapStateToPropsType) => {\r\n\r\n        let {isAuth, ...restProps} = props\r\n\r\n        if (!isAuth) return <Redirect to = \"/login\" />\r\n\r\n        return <Component {...restProps as T} />\r\n    }\r\n\r\n    let ConnectedAuthRedirectComponent = connect(mapStateToProps)(RedirectComponent)\r\n\r\n    return ConnectedAuthRedirectComponent\r\n}\r\n\r\n\r\n\r\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"names":["Paginator","props","useState","rightBorder","setRightBorder","leftBorder","setLeftBorder","pagesCount","count","Math","ceil","totalUsersCount","pageSize","i","push","setPaginatorBorder","p","useEffect","currentPage","paginator","map","finalSpanClass","s","className","onClick","changeCurrentPage","buttonOnClick","e","currentTarget","name","User","user","to","id","src","photos","small","userPhoto","alt","followed","disabled","followingInProgress","some","unfollow","follow","status","Users","isFetching","Preloader","users","u","assertIsFunction","func","errorMessage","TypeError","assertIsObject","object","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","every","itemTypes","join","assertIsArrayOfFunctions","collectInputSelectorResults","inputSelectorArgs","inputSelectorResults","length","apply","Symbol","Object","getPrototypeOf","Ref","WeakRef","value","this","weakMapMemoize","lastResult","options","fnNode","v","o","resultEqualityCheck","resultsCount","memoized","cacheNode","arguments","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","result","terminatedNode","lastResultValue","deref","needsWeakRef","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","memoizeOptionsFromArgs","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector2","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","argsMemoize","argsMemoizeOptions","finalMemoizeOptions","devModeChecks","finalArgsMemoizeOptions","memoizedResultFunc","selector","assign","resetDependencyRecomputations","resetRecomputations","withTypes","createSelector","createStructuredSelector","inputSelectorsObject","selectorCreator","inputSelectorKeys","keys","key","structuredSelector","reduce","composition","index","getUsers","state","usersState","getUsersWithReselect","filter","getCurrentPage","getPageSize","getTotalUserCount","getIsFetching","getFollowingInProgress","UsersCompContainer","numberPage","setCurrentPage","toggleFollowingProgress","unFollow","React","compose","withAuthRedirect","connect","requestUsers","mapStateToProps","isAuth","auth","Component","restProps","_objectWithoutProperties","source","excluded","target","getOwnPropertySymbols","sourceSymbolKeys","indexOf","prototype","propertyIsEnumerable","call","_slicedToArray","arr","_i","iterator","_s","_e","_arr","_n","_d","next","done","err","unsupportedIterableToArray"],"sourceRoot":""}